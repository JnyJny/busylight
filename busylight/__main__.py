"""
"""

from contextlib import suppress
from enum import Enum

from typing import List, Optional

import typer
import webcolors

from loguru import logger

from .lights import USBLight
from .lights import ColorTuple, Effects, Speed, parse_color
from .manager import LightManager


cli = typer.Typer()

webapi = typer.Typer()


manager = LightManager()

lights = []


@cli.callback()
def global_callback(
    ctx: typer.Context,
    debug: bool = typer.Option(False, "--debug", "-D", is_flag=True),
    targets: str = typer.Option("", "--light-id", "-l"),
    all_lights: bool = typer.Option(False, "--all", "-a"),
) -> None:
    """Control USB connected presense lights."""

    (logger.enable if debug else logger.disable)("busylight")

    if all_lights:
        return
    for target in targets.split(","):
        logger.debug(f"target {target}")
        for sep in ["-", ":"]:
            if sep in target:
                logger.debug(f"found {sep} in {target}")
                start, _, end = target.partition(sep)
                logger.debug(f"building range {start} to {end}")
                lights.extend(list(range(int(start), int(end) + 1)))
                break
        else:
            with suppress(ValueError):
                lights.append(int(target))

    logger.debug(f"{lights=}")


@cli.command(name="on")
def turn_lights_on(
    color: Optional[str] = typer.Argument("green"),
) -> None:
    """Activate lights with a color."""

    color = parse_color(color)

    manager.on(color, lights)


@cli.command(name="off")
def turn_lights_off() -> None:
    """Deactivate lights."""
    logger.debug("deactivating lights")

    manager.off(lights)


@cli.command(name="blink")
def blink_lights(
    color: Optional[str] = typer.Argument("red"),
    blink: Speed = typer.Argument(Speed.Slow),
) -> None:
    """Blink lights on and off."""

    color = parse_color(color)

    manager.apply_effect(Effects.for_name("blink")(color, blink.duty_cycle), lights)


@cli.command(name="rainbow")
def rainbow_lights(speed: Speed = typer.Argument(Speed.Slow)) -> None:
    """Display rainbow colors on specified lights."""

    manager.apply_effect(Effects.for_name("spectrum")(speed.duty_cycle), lights)


@cli.command(name="list")
def list_available_lights(
    verbose: bool = typer.Option(False, "--verbose", "-v", is_flag=True),
) -> None:
    """List currently connected lights.

    Lights in this list are currently plugged in and available for
    use. The `--verbose` flag will increase the amount of information
    displayed for each light.
    """
    logger.debug(f"listing connected lights {lights=}")

    for light in manager.selected_lights(lights):
        typer.secho(f"{manager.lights.index(light):3d} ", nl=False, fg="red")
        typer.secho(light.name, fg="green")
        if not verbose:
            continue
        for k, v in light.hidinfo.items():
            if v:
                typer.secho(f"   {k:>20s}:", nl=False)
                if isinstance(v, int):
                    typer.secho(f"{v:04x}", fg="blue")
                    continue
                if isinstance(v, bytes):
                    typer.secho(v.decode("utf-8"), fg="red")
                    continue
                typer.secho(v, fg="green")


@cli.command(name="supported")
def list_supported_lights() -> None:
    """List supported lights."""
    logger.debug("listing supported lights")
    for vendor, names in USBLight.supported_lights().items():
        typer.secho(vendor, fg="blue")
        for name in names:
            typer.secho("  - ", nl=False)
            typer.secho(name, fg="green")


@cli.command(name="udev-rules")
def generate_udev_rules(
    output: typer.FileTextWrite = typer.Option("-", "--output", "-o"),
) -> None:
    """Generate Linux udev rules for all supported lights.

    The rule file generated by this subcommand includes rules for all
    known supported devices. By default, these devices' file permissions
    are set to 0666 when detected by the udev subsystem. Users are
    encouraged to tailor these rules to suit their security needs.
    """

    logger.debug("generating udev rules")

    rules = USBLight.udev_rules()
    about = [
        "# Generated by `busylight udev-rules` https://github.com/JnyJny/busylight",
        "#",
    ]

    print("\n".join(about + rules), file=output)


@webapi.command()
def serve_web_api(
    debug: bool = typer.Option(False, "--debug", "-D", is_flag=True),
    host: str = typer.Option("0.0.0.0", "--host"),
    port: int = typer.Option(21169, "--port", "-p"),
) -> None:
    """Serve a web API to access connected lights."""
    (logger.enable if debug else logger.disable)("busylight")
    logger.debug("serving web api")
